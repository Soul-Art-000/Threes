<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Threes!</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700;800&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Nunito', sans-serif;
            background-color: #faf8ef;
            overflow: hidden; /* Prevent scrolling on mobile */
            touch-action: none;
        }

        .game-container {
            background-color: #bbada0;
            border-radius: 6px;
            width: 300px;
            height: 300px;
            position: relative;
            padding: 10px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            gap: 10px;
            touch-action: none;
        }

        .grid-cell {
            background-color: rgba(238, 228, 218, 0.35);
            border-radius: 3px;
            width: 100%;
            height: 100%;
        }

        .tile {
            position: absolute;
            width: 62.5px; /* (300 - 50) / 4 */
            height: 62.5px;
            border-radius: 3px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 24px;
            transition: transform 0.15s ease-in-out;
            z-index: 10;
        }

        /* Tile Colors */
        .tile-1 { background: #60d6fa; color: white; }
        .tile-2 { background: #ff5c77; color: white; }
        .tile-3 { background: #ffffff; color: #333; }
        .tile-6 { background: #ffffff; color: #333; }
        .tile-12 { background: #ffffff; color: #333; border: 1px solid #eee; }
        .tile-24, .tile-48, .tile-96 { background: #f2b179; color: white; }
        .tile-192, .tile-384 { background: #f59563; color: white; }
        
        .scoreboard-entry {
            transition: all 0.2s;
        }
        .scoreboard-entry:hover {
            background-color: #f3f4f6;
        }

        /* Modal Overlay */
        #nameModal {
            backdrop-filter: blur(5px);
        }

        /* Shake animation for invalid moves */
        @keyframes shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
            75% { transform: translateX(-5px); }
            100% { transform: translateX(0); }
        }
        .shake {
            animation: shake 0.3s;
        }
    </style>
</head>
<body class="h-screen w-full flex flex-col md:flex-row items-center justify-center p-4 bg-gray-50 text-gray-800">

    <!-- Game Section -->
    <div class="flex flex-col items-center space-y-4 w-full md:w-auto">
        <div class="flex justify-between w-[300px] items-end">
            <div>
                <h1 class="text-4xl font-extrabold text-gray-700">Threes!</h1>
                <p class="text-sm text-gray-500">BirleÅŸtir: 1+2=3</p>
            </div>
            <div class="text-right">
                <div class="text-xs font-bold text-gray-400 uppercase">Skor</div>
                <div class="text-2xl font-bold text-gray-700" id="current-score">0</div>
            </div>
        </div>

        <div class="relative">
            <div class="game-container" id="grid-container">
                <!-- Grid Cells created by JS -->
            </div>
            <div id="tile-container">
                <!-- Tiles injected by JS -->
            </div>
            
            <!-- Next Tile Indicator -->
            <div class="absolute -top-10 left-1/2 transform -translate-x-1/2 bg-white px-3 py-1 rounded shadow text-xs font-bold flex items-center gap-2">
                Sonraki: <span id="next-tile-indicator" class="w-4 h-4 rounded inline-block bg-blue-400"></span>
            </div>
        </div>

        <button onclick="resetGame()" class="w-[300px] py-3 bg-gray-800 text-white font-bold rounded shadow hover:bg-gray-700 transition flex items-center justify-center gap-2">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 12"/><path d="M3 3v9h9"/></svg>
            Tekrar BaÅŸla
        </button>
        
        <p class="text-xs text-gray-400 w-[300px] text-center">
            Ok tuÅŸlarÄ±nÄ± veya parmaÄŸÄ±nÄ± kullanarak taÅŸlarÄ± kaydÄ±r.
        </p>
    </div>

    <!-- Scoreboard Section -->
    <div class="mt-8 md:mt-0 md:ml-12 w-full md:w-80 h-[500px] bg-white rounded-lg shadow-lg flex flex-col overflow-hidden border border-gray-200">
        <div class="p-4 bg-gray-50 border-b border-gray-200">
            <h2 class="text-lg font-bold text-gray-700 flex items-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-yellow-500"><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"/><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"/><path d="M4 22h16"/><path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"/><path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"/><path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"/></svg>
                Lider Tablosu
            </h2>
        </div>
        <div id="scoreboard-list" class="flex-1 overflow-y-auto p-2 space-y-1">
            <div class="text-center text-gray-400 py-10">Veriler yÃ¼kleniyor...</div>
        </div>
        <div class="p-2 text-xs text-center text-gray-400 border-t bg-gray-50">
            GerÃ§ek zamanlÄ± gÃ¼ncellenir.
        </div>
    </div>

    <!-- Name Input Modal -->
    <div id="nameModal" class="fixed inset-0 bg-black/50 hidden items-center justify-center z-50">
        <div class="bg-white p-6 rounded-lg shadow-2xl w-80 transform transition-all scale-100">
            <h3 class="text-xl font-bold mb-2 text-gray-800">Harika Skor!</h3>
            <p class="text-gray-600 mb-4 text-sm">Lider tablosuna girmek iÃ§in ismini bahÅŸet.</p>
            <input type="text" id="playerName" placeholder="Ä°sminiz (Ã–rn: Soul)" class="w-full border border-gray-300 rounded p-2 mb-4 focus:outline-none focus:border-blue-500" maxlength="15">
            <button onclick="submitScore()" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 rounded transition">
                Kaydet
            </button>
            <button onclick="closeModal()" class="w-full mt-2 text-gray-500 text-sm hover:text-gray-700">
                Kaydetmeden GeÃ§
            </button>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getFirestore, collection, addDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";

        // --- Firebase Config & Init ---
        const firebaseConfig = JSON.parse(__firebase_config);
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        const appId = __app_id || 'default-threes';
        let currentUser = null;

        // Auth Flow
        const initAuth = async () => {
            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                await signInWithCustomToken(auth, __initial_auth_token);
            } else {
                await signInAnonymously(auth);
            }
        };
        
        initAuth();
        onAuthStateChanged(auth, (user) => {
            currentUser = user;
            if (user) loadScores();
        });

        // --- Game Logic Constants ---
        const SIZE = 4;
        const CELL_SIZE = 65; // px + margin logic approximated
        const GAP = 10;
        
        let grid = [];
        let score = 0;
        let nextTileValue = 1;
        let gameOver = false;

        // UI References
        const gridEl = document.getElementById('grid-container');
        const tileContainer = document.getElementById('tile-container');
        const scoreEl = document.getElementById('current-score');
        const nextTileIndicator = document.getElementById('next-tile-indicator');
        const modal = document.getElementById('nameModal');
        const nameInput = document.getElementById('playerName');

        // --- Game Engine ---

        function initGame() {
            // Create background grid cells
            gridEl.innerHTML = '';
            for(let i=0; i<16; i++) {
                let cell = document.createElement('div');
                cell.className = 'grid-cell';
                gridEl.appendChild(cell);
            }
            resetGame();
            setupInput();
        }

        window.resetGame = function() {
            grid = Array(SIZE).fill().map(() => Array(SIZE).fill(null));
            score = 0;
            gameOver = false;
            updateScore(0);
            
            // Initial tiles (usually 9 random tiles in Threes)
            addRandomTile();
            addRandomTile();
            addRandomTile();
            addRandomTile();
            addRandomTile();
            addRandomTile();
            addRandomTile();
            addRandomTile();
            addRandomTile();

            setNextTile();
            drawGrid();
        }

        function addRandomTile() {
            let emptyCells = [];
            for(let r=0; r<SIZE; r++){
                for(let c=0; c<SIZE; c++){
                    if(!grid[r][c]) emptyCells.push({r, c});
                }
            }
            if(emptyCells.length > 0) {
                let cell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                let val = Math.random() < 0.5 ? 1 : 2; 
                // Rarely a 3 in initial setup, but kept simple here
                grid[cell.r][cell.c] = { value: val, id: Math.random() };
            }
        }

        function setNextTile() {
            // Threes logic: next tile is usually in a "deck"
            // Simplified: Random 1, 2, or 3 (bonus)
            const r = Math.random();
            if (r < 0.4) nextTileValue = 1;
            else if (r < 0.8) nextTileValue = 2;
            else nextTileValue = 3;

            // Update UI indicator color
            nextTileIndicator.className = 'w-4 h-4 rounded inline-block ' + 
                (nextTileValue === 1 ? 'bg-[#60d6fa]' : 
                 nextTileValue === 2 ? 'bg-[#ff5c77]' : 'bg-white border border-gray-300');
            nextTileIndicator.innerText = nextTileValue > 2 ? '+' : '';
        }

        function drawGrid() {
            tileContainer.innerHTML = '';
            for(let r=0; r<SIZE; r++){
                for(let c=0; c<SIZE; c++){
                    if(grid[r][c]) {
                        createTileElement(r, c, grid[r][c]);
                    }
                }
            }
        }

        function createTileElement(r, c, tileData) {
            const el = document.createElement('div');
            el.className = `tile tile-${tileData.value > 384 ? '384' : tileData.value}`;
            el.textContent = tileData.value;
            
            // Position calculation
            // grid padding: 10px. gap: 10px. cell: 62.5px.
            // left = 10 + c * (62.5 + 10)
            const left = 10 + c * 72.5;
            const top = 10 + r * 72.5;
            
            el.style.transform = `translate(${left}px, ${top}px)`;
            
            // If it's a new merged tile, pop animation?
            // (omitted for brevity, utilizing CSS transition)
            
            tileContainer.appendChild(el);
        }

        function updateScore(points) {
            score += points;
            scoreEl.textContent = score;
        }

        // --- Move Logic (The Heart of Threes) ---
        // Unlike 2048, Threes shifts the board by 1 unit, inserting a new tile at the edge.

        function move(direction) {
            if (gameOver) return;

            // Direction: 0:Up, 1:Right, 2:Down, 3:Left
            // Delta for r, c
            const dr = [-1, 0, 1, 0][direction];
            const dc = [0, 1, 0, -1][direction];

            let moved = false;
            let merged = Array(SIZE).fill().map(() => Array(SIZE).fill(false));
            
            // Order of processing matters. 
            // Up (dr=-1): Process row 0 to 3? No, we check if items can move INTO the space.
            // We iterate from the destination side backwards.
            
            let traverseR = [], traverseC = [];
            for(let i=0; i<SIZE; i++) {
                traverseR.push(i);
                traverseC.push(i);
            }

            // If moving Down (1) or Right (1), we traverse from end to start to avoid overwriting
            if (dr === 1) traverseR.reverse();
            if (dc === 1) traverseC.reverse();

            // Store current state to check changes
            const originalGrid = JSON.stringify(grid);

            // Logic:
            // Shift the whole board.
            // A move is valid if at least one tile moves.
            // A tile moves if the target cell is empty OR can merge.
            
            // We need to process columns individually for vertical moves, rows for horizontal.
            // Because in Threes, if one column is blocked, it doesn't move, but others might.
            
            let linesMoved = 0; // Track specifically which lines moved to insert new tiles

            if (dc === 0) { // Vertical Move
                for (let c = 0; c < SIZE; c++) {
                    // Check if this column can shift
                    if (canShiftLine(c, dr, true)) {
                        shiftLine(c, dr, true);
                        linesMoved++;
                        moved = true;
                        // Insert new tile at the entry point
                        let entryR = dr === 1 ? 0 : SIZE - 1; // If moving down, enters top. 
                        grid[entryR][c] = { value: nextTileValue, id: Math.random() };
                    }
                }
            } else { // Horizontal Move
                for (let r = 0; r < SIZE; r++) {
                    if (canShiftLine(r, dc, false)) {
                        shiftLine(r, dc, false);
                        linesMoved++;
                        moved = true;
                        let entryC = dc === 1 ? 0 : SIZE - 1;
                        grid[r][entryC] = { value: nextTileValue, id: Math.random() };
                    }
                }
            }

            if (moved) {
                drawGrid();
                setNextTile(); // Prep next card
                checkGameOver();
            } else {
                 // Shake animation on grid to indicate blocked move
                 gridEl.classList.add('shake');
                 setTimeout(() => gridEl.classList.remove('shake'), 300);
            }
        }

        // isVertical: true for cols, false for rows
        function canShiftLine(index, delta, isVertical) {
            // We check if the leading edge can move or push.
            // In Threes, the "Edge" is the side we are moving towards.
            // e.g. Moving UP (delta -1), we look at row 0. 
            // If row 0 is empty, everything shifts? No, in Threes, items only shift if they are pushed against the wall or a merge happens.
            // Actually, simply: iterate from the direction we are moving TO.
            
            // Let's model it:
            // 1. Get the line as an array.
            // 2. Try to shift elements by 1 index.
            // 3. If arr[i] moves to arr[i-1], arr[i-1] must be empty or mergeable.
            
            let line = [];
            for(let i=0; i<SIZE; i++) {
                line.push(isVertical ? grid[i][index] : grid[index][i]);
            }

            // Delta -1 means moving towards index 0.
            // Delta 1 means moving towards index 3.
            
            // If moving to 0 (Up/Left):
            if (delta === -1) {
                // Check from 0 to 3. 
                for (let i = 0; i < SIZE - 1; i++) {
                     // Can line[i+1] move into line[i]?
                     let current = line[i+1];
                     let target = line[i];
                     
                     if (!current) continue; // Nothing to move
                     
                     if (!target) return true; // Empty space, can shift
                     if (canMerge(current.value, target.value)) return true; // Merge, can shift
                }
                // If the board is full but the edge is empty? No, Threes fills edge.
            } 
            // If moving to 3 (Down/Right):
            else {
                for (let i = SIZE - 1; i > 0; i--) {
                    let current = line[i-1];
                    let target = line[i];
                    if (!current) continue;
                    
                    if (!target) return true;
                    if (canMerge(current.value, target.value)) return true;
                }
            }

            return false;
        }

        function shiftLine(index, delta, isVertical) {
            // Perform the shift
             let line = [];
            for(let i=0; i<SIZE; i++) {
                line.push(isVertical ? grid[i][index] : grid[index][i]);
            }

            if (delta === -1) { // Shift Left/Up (Indices decrease)
                 for (let i = 0; i < SIZE - 1; i++) {
                     let current = line[i+1];
                     let target = line[i];
                     if (!current) continue; // Skip empty source
                     
                     if (!target) {
                         // Move to empty
                         line[i] = current;
                         line[i+1] = null;
                     } else if (canMerge(current.value, target.value)) {
                         // Merge
                         let newVal = current.value + target.value;
                         line[i] = { value: newVal, id: target.id }; // Keep id stable? or new?
                         line[i+1] = null;
                         updateScore(newVal); // Score is the face value of created tile
                         // Important: In Threes, a merge stops the shift for that specific interaction in this step? 
                         // No, the whole line shifts 1 unit. 
                         // But we only process one merge per line per turn usually?
                         // For simplicity in this implementation, we allow the shift.
                         break; // One merge per line per move usually in simplified logic to prevent cascading
                     }
                 }
            } else { // Shift Right/Down (Indices increase)
                for (let i = SIZE - 1; i > 0; i--) {
                    let current = line[i-1];
                    let target = line[i];
                    if (!current) continue;

                    if (!target) {
                        line[i] = current;
                        line[i-1] = null;
                    } else if (canMerge(current.value, target.value)) {
                        let newVal = current.value + target.value;
                        line[i] = { value: newVal, id: target.id };
                        line[i-1] = null;
                        updateScore(newVal);
                        break;
                    }
                }
            }

            // Write back
            for(let i=0; i<SIZE; i++) {
                if (isVertical) grid[i][index] = line[i];
                else grid[index][i] = line[i];
            }
        }

        function canMerge(v1, v2) {
            if (v1 === 1 && v2 === 2) return true;
            if (v1 === 2 && v2 === 1) return true;
            if (v1 > 2 && v2 > 2 && v1 === v2) return true;
            return false;
        }

        function checkGameOver() {
            // Game over if no moves possible
            // 1. Are there empty cells?
            for(let r=0; r<SIZE; r++)
                for(let c=0; c<SIZE; c++)
                    if(!grid[r][c]) return;

            // 2. Can any line shift?
            // Check rows (Horiz)
            for (let r=0; r<SIZE; r++) {
                 if(canShiftLine(r, 1, false) || canShiftLine(r, -1, false)) return;
            }
            // Check cols (Vert)
            for (let c=0; c<SIZE; c++) {
                if(canShiftLine(c, 1, true) || canShiftLine(c, -1, true)) return;
            }

            gameOver = true;
            if(score > 0) {
                // Slight delay for visual effect
                setTimeout(() => {
                    modal.classList.remove('hidden');
                    modal.classList.add('flex');
                }, 1000);
            }
        }

        // --- Inputs ---
        function setupInput() {
            document.addEventListener('keydown', (e) => {
                if (modal.classList.contains('flex')) return; // Input open

                switch(e.key) {
                    case 'ArrowUp': move(0); break;
                    case 'ArrowRight': move(1); break;
                    case 'ArrowDown': move(2); break;
                    case 'ArrowLeft': move(3); break;
                }
            });

            // Touch support
            let touchStartX = 0;
            let touchStartY = 0;
            const gameEl = document.querySelector('.game-container');

            gameEl.addEventListener('touchstart', (e) => {
                touchStartX = e.changedTouches[0].screenX;
                touchStartY = e.changedTouches[0].screenY;
                e.preventDefault();
            }, {passive: false});

            gameEl.addEventListener('touchend', (e) => {
                if (modal.classList.contains('flex')) return;

                let touchEndX = e.changedTouches[0].screenX;
                let touchEndY = e.changedTouches[0].screenY;
                
                let dx = touchEndX - touchStartX;
                let dy = touchEndY - touchStartY;

                if (Math.abs(dx) > Math.abs(dy)) {
                    // Horizontal
                    if (Math.abs(dx) > 30) move(dx > 0 ? 1 : 3);
                } else {
                    // Vertical
                    if (Math.abs(dy) > 30) move(dy > 0 ? 2 : 0);
                }
                e.preventDefault();
            }, {passive: false});
        }

        // --- Firestore Scoreboard ---

        window.submitScore = async function() {
            if (!currentUser) return;
            const name = nameInput.value.trim() || "Anonim";
            
            try {
                await addDoc(collection(db, 'artifacts', appId, 'public', 'data', 'scores'), {
                    name: name,
                    score: score,
                    timestamp: Date.now(),
                    userId: currentUser.uid
                });
                closeModal();
                resetGame(); // Auto restart after save
            } catch (e) {
                console.error("Skor kaydedilemedi:", e);
                alert("Hata oluÅŸtu, skor kaydedilemedi.");
            }
        }

        window.closeModal = function() {
            modal.classList.remove('flex');
            modal.classList.add('hidden');
        }

        function loadScores() {
            if (!currentUser) return;
            
            const q = collection(db, 'artifacts', appId, 'public', 'data', 'scores');
            
            onSnapshot(q, (snapshot) => {
                const scores = [];
                snapshot.forEach(doc => {
                    scores.push(doc.data());
                });

                // Client-side sorting (Rule 2 compliant)
                scores.sort((a, b) => b.score - a.score);
                
                // Keep top 50
                const topScores = scores.slice(0, 50);
                
                renderScoreboard(topScores);
            }, (error) => {
                console.error("Scoreboard error:", error);
            });
        }

        function renderScoreboard(scores) {
            const list = document.getElementById('scoreboard-list');
            list.innerHTML = '';
            
            if (scores.length === 0) {
                list.innerHTML = '<div class="text-center text-gray-400 py-4">HenÃ¼z skor yok. Ä°lk sen ol!</div>';
                return;
            }

            scores.forEach((s, index) => {
                const el = document.createElement('div');
                el.className = 'scoreboard-entry flex justify-between items-center p-2 rounded cursor-default border-b border-gray-100 last:border-0';
                
                // Crown for top 3
                let rankDisplay = `<span class="font-bold text-gray-400 w-6">${index + 1}.</span>`;
                if (index === 0) rankDisplay = `<span class="w-6 text-yellow-500">ðŸ‘‘</span>`;
                if (index === 1) rankDisplay = `<span class="w-6 text-gray-400">ðŸ¥ˆ</span>`;
                if (index === 2) rankDisplay = `<span class="w-6 text-orange-400">ðŸ¥‰</span>`;

                el.innerHTML = `
                    <div class="flex items-center gap-2">
                        ${rankDisplay}
                        <span class="font-semibold text-gray-700 truncate max-w-[120px]">${escapeHtml(s.name)}</span>
                    </div>
                    <span class="font-bold text-blue-600">${s.score}</span>
                `;
                list.appendChild(el);
            });
        }

        function escapeHtml(text) {
            if (!text) return text;
            return text
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        // Start
        initGame();

    </script>
</body>
</html>
